"""
Implementation of SeCo / Covering algorithm:
Helpers in addition to the algorithms in `concrete.py`.
"""
import json
import math
import warnings
from itertools import zip_longest
from typing import Optional, Union, Sequence, Tuple, Mapping

import numpy as np
from matplotlib.figure import Figure  # needed only for type hints
from sklearn.exceptions import NotFittedError

from sklearn_seco.abstract import _BinarySeCoEstimator
from sklearn_seco.common import \
    SeCoBaseImplementation, AugmentedRule, Theory, rule_ancestors


_JSON_DUMP_DESCRIPTION = "sklearn_seco.extra.trace_coverage dump"


def _json_encode_ndarray(obj):
    if isinstance(obj, np.ndarray):
        return obj.tolist()
    raise TypeError


# TODO: implement tracing of estimator instances (not only classes)


def trace_coverage(cls):
    """Decorator for SeCoBaseImplementation subclasses, that adds tracing of
    (p,n) while building the theory, and ability to plot these.
    Relies on :class:`_TraceCoverage`, for field documentation see there.

    Usage
    =====

    Use with decorator syntax:

    >>> @trace_coverage
    >>> class MySeCoImpl(SeCoBaseImplementation):
    >>>     ...

    or call directly:

    >>> MyTracedSeCoImpl = trace_coverage(MySeCoImpl)
    """
    class TracedImplementation(_TraceCoverage, cls):
        pass
    return TracedImplementation


class _TraceCoverage(SeCoBaseImplementation):
    """Mixin tracing (p,n) while building the theory, able to plot these.

    Note this always has to come first in the mro/inheritance tree, because it
    overrides some methods not to be overridden. Use the `trace_coverage`
    decorator to ensure that.

    Class fields / trace content:
    =====

    - `trace_level`
      specifies detail level to trace:
        - `theory` only traces each of the `best_rule` in the theory
        - `ancestors` traces each `best_rule` and the refinement steps used
          to find it (starting with the `init_rule` return value).
        - `refinements` traces every rule generated by `refine_rule`.

    - `coverage_log`: list of np.array with shape (n_ancestors, 2)
       This is the log of `best_rule` and (if requested) their `ancestors`.
       For each `best_rule` +1 it keeps an array with (p, n) for that best rule
       and its ancestors, in reverse order of creation.
       The last `best_rule` is not part

    - `refinement_log`: list of np.array with shape (n_refinements, 3)
       This is the log of all `refinements`. For each `best_rule` (i.e. iteration
       in `abstract_seco`) +1 (which corresponds to the attempts to find
       another rule, aborted by `rule_stopping_criterion`), it keeps an array
       with (p, n, stop) for each refinement, where `stop` is the boolean
       result of `inner_stopping_criterion(refinement)`.

    - `last_rule_stop`: boolean result of `rule_stopping_criterion` on the last
       found `best_rule`. If False, it is part of the theory (and the rule
       search ended because all positive examples were covered), if True it is
       not part of the theory (the search ended because
       `rule_stopping_criterion` was True).

    - `PN`: np.array of shape (n_best_rules, 2)
       This is the log of the (P, N) values for each iteration of
       `abstract_seco`.
    """

    def __init__(self, trace_level='refinements', **kwargs):
        super().__init__(**kwargs)
        self.trace_level = trace_level
        self.has_complete_trace = False
        self.coverage_log = []
        self.refinement_log = []
        self.PN = []
        self.last_rule_stop = None

    def set_context(self, estimator: _BinarySeCoEstimator, X, y):
        # note we're called before each find_best_rule
        super().set_context(estimator, X, y)
        # if we're in a new abstract_seco run: delete the old results
        if self.has_complete_trace:
            self.has_complete_trace = False
            self.coverage_log = []
            self.refinement_log = []  # type while tracing: list of
            # (list or np.ndarray) of np.array [n,p,stop]
            self.last_rule_stop = None
            self.PN = []  # type while tracing: list of tuple(int, int)
        self.PN.append((self.P, self.N))

        if self.trace_level == 'refinements':
            self.refinement_log.append([])

    def inner_stopping_criterion(self, refinement: AugmentedRule) -> bool:
        stop = super().inner_stopping_criterion(refinement)
        p, n = self.count_matches(refinement)
        self.refinement_log[-1].append(np.array((p, n, stop)))
        return stop

    def rule_stopping_criterion(self, theory: Theory, rule: AugmentedRule
                                ) -> bool:
        self.last_rule_stop = super().rule_stopping_criterion(theory, rule)

        def pn(rule):
            return self.count_matches(rule)

        if self.trace_level == 'best_rules':
            self.coverage_log.append(np.array([pn(rule)]))
        else:  # elif trace_level in ('ancestors', 'refinements'):
            self.coverage_log.append(
                np.array([pn(r) for r in rule_ancestors(rule)]))

        if self.trace_level == 'refinements':
            self.refinement_log[-1] = np.array(self.refinement_log[-1])

        return self.last_rule_stop

    def unset_context(self):
        super().unset_context()
        # end of rule search, theory is complete
        self.has_complete_trace = True
        self.PN = np.array(self.PN)

    @property
    def n_rules(self):
        return len(self.coverage_log)

    def to_json(self):
        """:return: A string containing a JSON representation of the trace."""
        if not self.has_complete_trace:
            raise NotFittedError("No trace collected yet.")
        return json.dumps({
            "description": _JSON_DUMP_DESCRIPTION,
            "version": 1,
            "coverage_log": self.coverage_log,
            "refinement_log": self.refinement_log,
            "last_rule_stop": self.last_rule_stop,
            "PN": self.PN,
        }, allow_nan=False, default=_json_encode_ndarray)

    @classmethod
    def from_json(cls, dump) -> Mapping:
        """
        :param dump: A file-like object or string containing JSON.
        :return: A dict representing the trace dumped previously with
            `to_json`. To plot, pass its items as kwargs to
            :func:`plot_coverage_log`: `plot_coverage_log(**from_json(dump))`.
        """
        loader = json.loads if isinstance(dump, str) else json.load
        dec = loader(dump)

        if dec["description"] != _JSON_DUMP_DESCRIPTION:
            raise ValueError("No/invalid coverage trace json: %s" % repr(dec))
        if dec["version"] != 1:
            raise ValueError("Unsupported coverage trace version: %s"
                             % dec["version"])
        del dec["description"]
        del dec["version"]
        # convert back to numpy arrays
        for i in range(len(dec["coverage_log"])):
            dec["coverage_log"][i] = np.array(dec["coverage_log"][i])
        for i in range(len(dec["refinement_log"])):
            dec["refinement_log"][i] = np.array(dec["refinement_log"][i])
        return dec

    def plot_coverage_log(self, **kwargs):
        """Plot the trace, see :func:`plot_coverage_log`."""
        if not self.has_complete_trace:
            raise NotFittedError("No trace collected yet.")
        return plot_coverage_log(self.last_rule_stop, self.PN,
                                 self.coverage_log, self.refinement_log,
                                 **kwargs)


def plot_coverage_log(
        last_rule_stop, PN, coverage_log, refinement_log,
        *,
        title: Optional[str] = None,
        draw_refinements: Union[str, bool] = 'nonzero',
        theory_figure: Optional[Figure] = None,
        rules_figure: Union[Figure, Sequence[Figure], None] = None,
        rules_use_subfigures: bool = True,
) -> Tuple[Figure, Union[Figure, Sequence[Figure]]]:
    """Plot the traced (p, n) of a theory.

    For parameters `last_rule_stop`, `PN`, `coverage_log` and `refinement_log`,
    see :class:`__TraceCoverage`.

    :param title: string or None. If not None, set figure titles and use
      this value as prefix.
    :param theory_figure: If None, use `plt.figure()` to create a figure
      for the theory plot, otherwise use this parameter.
    :param rules_figure: If `None`, use `plt.figure()` to create a figure
      (using subfigures) or a list of figures for the rules plot(s),
      otherwise use this parameter.
      If `rules_use_subfigure`, `rules_figure` has to be None or a list of
      figures of same length as `coverage_log`.
    :param rules_use_subfigures: If True, the rules plots are placed as
      subfigures in a common figure, otherwise they're drawn as separate
      figures.
    :param draw_refinements: If `True`, draw all refinements, if `False`
      don't. If `'nonzero'` (the default) only draw those with `n > 0`.
    :return: `(theory_figure, rules_figure)` where rules_figure is a figure
      or a list of figure, depending on `rules_use_subfigure`.
    """

    P, N = 0, 1  # readable indexes, not values!

    n_rules = len(coverage_log)
    if not n_rules:
        # issue a warning, user can decide handling. See module `warnings`
        warnings.warn("Empty coverage_log collected, useless plot.")
    if draw_refinements and len(refinement_log) < n_rules:
        warnings.warn("draw_refinements=True requested, but no refinement_log "
                      "collected. Using draw_refinements=False.")
        draw_refinements = False

    PN0 = PN[0]
    rnd_style = dict(color='grey', alpha=0.5, linestyle='dotted')
    refinements_style = dict(marker='.', markersize=1, linestyle='',
                             zorder=-1,)

    import matplotlib.pyplot as plt
    from matplotlib.ticker import AutoLocator

    if theory_figure is None:
        theory_figure = plt.figure()
    theory_axes = theory_figure.gca(xlabel='n', ylabel='p',
                                    xlim=(0, PN0[N]), ylim=(0, PN0[P]))
    theory_axes.locator_params(integer=True)
    # draw "random theory" reference marker
    theory_axes.plot([0, PN0[N]], [0, PN0[P]], **rnd_style)

    if rules_use_subfigures:
        if rules_figure is None:
            rules_figure = plt.figure(figsize=(10.24, 10.24),
                                      tight_layout=True)
        # else assume rules_figure is already a figure
        if title is not None:
            rules_figure.suptitle("%s: Rules" % title, y=0.02)
        # TODO: axis labels when using subfigures
        subfigure_grid = [math.ceil(np.sqrt(n_rules))] * 2
        rule_axes = [rules_figure.add_subplot(*subfigure_grid, rule_idx + 1)
                     for rule_idx in range(n_rules)]
    else:
        if rules_figure is None:
            rules_figure = [plt.figure() for _ in range(n_rules)]
        elif isinstance(rules_figure, Sequence):
            if len(rules_figure) != n_rules:
                raise ValueError("rules_figure is a list, but length ({}) "
                                 "differs from n_rules ({})."
                                 .format(len(rules_figure), n_rules))
        else:
            raise ValueError("got rules_use_subfigures=False, thus "
                             "rules_figure has to be None or a list of "
                             "figures, instead got " + str(rules_figure))
        # assume rules_figure is a list of figures
        rule_axes = [f.gca() for f in rules_figure]

    previous_rule = np.array((0, 0))  # equals (N, P) for some trace
    for rule_idx, (rule_trace, refinements) in \
            enumerate(zip_longest(coverage_log, refinement_log)):
        PNi = PN[rule_idx]
        if draw_refinements == 'nonzero':
            refts_mask = refinements[:, P] != 0
        elif draw_refinements:
            refts_mask = slice(None)  # all
        mark_stop = last_rule_stop and (rule_idx == n_rules - 1)

        # this rule in theory plot
        rule = rule_trace[0] + previous_rule
        theory_line = theory_axes.plot(
            rule[N], rule[P], 'x' if mark_stop else '.',
            label="{i:{i_width}}: ({p:4}, {n:4})"
                  .format(n=rule[N], p=rule[P], i=rule_idx,
                          i_width=math.ceil(np.log10(n_rules))))
        rule_color = theory_line[0].get_color()
        if draw_refinements:
            # draw refinements in theory plot
            theory_axes.plot(refinements[refts_mask, N] + previous_rule[N],
                             refinements[refts_mask, P] + previous_rule[P],
                             color=rule_color, alpha=0.3,
                             **refinements_style)
        # draw arrows between best_rules
        # NOTE: invert coordinates because we save (p,n) and plot (x=n,y=p)
        theory_axes.annotate("", xytext=previous_rule[::-1], xy=rule[::-1],
                             arrowprops={'arrowstyle': "->"})
        previous_rule = rule

        # TODO: move ancestor plot to separate method. how get rule_color?
        # subplot with ancestors of current rule
        rule_axis = rule_axes[rule_idx]
        if mark_stop:
            rule_title_template = '(Rule #%d) Candidate'
        else:
            rule_title_template = 'Rule #%d'
        if not rules_use_subfigures and title is not None:
            # add title before each of the figures
            rule_title_template = "%s: %s" % (title, rule_title_template)
        rule_axis.set_title(rule_title_template % rule_idx)
        # draw "random theory" reference marker
        rule_axis.plot([0, PN0[N]], [0, PN0[P]], **rnd_style)
        # draw rule_trace
        rule_axis.plot(rule_trace[:, N], rule_trace[:, P], 'o-',
                       color=rule_color)
        if draw_refinements:
            # draw refinements as scattered dots
            rule_axis.plot(refinements[refts_mask, N],
                           refinements[refts_mask, P],
                           color='black', alpha=0.7, **refinements_style)

        # draw x and y axes through (0,0) and hide for negative values
        for spine_type, spine in rule_axis.spines.items():
            spine.set_position('zero')
            horizontal = spine_type in {'bottom', 'top'}
            spine.set_bounds(0, PNi[N] if horizontal else PNi[P])

        class PositiveTicks(AutoLocator):
            def tick_values(self, vmin, vmax):
                orig = super().tick_values(vmin, vmax)
                return orig[orig >= 0]

        rule_axis.xaxis.set_major_locator(PositiveTicks())
        rule_axis.yaxis.set_major_locator(PositiveTicks())
        rule_axis.locator_params(integer=True)

        # set reference frame (N,P), but move (0,0) so it looks comparable
        rule_axis.set_xbound(PNi[N] - PN0[N], PNi[N])
        rule_axis.set_ybound(PNi[P] - PN0[P], PNi[P])

    if title is not None:
        theory_axes.set_title("%s: Theory" % title)
    theory_figure.legend(title="rule: (p,n)", loc='center right')

    return theory_figure, rules_figure
